#! ${PYTHON_EXECUTABLE}
#-----------------------------------------------------------------------------#
## MonteCarlo.Collision.ScatteringCenterDefinition class unit tests
#  \file   tstMonteCarlo.Collision.ScatteringCenterDefinition.py
#  \author Luke Kersting
#  \brief  Unit tests for the MonteCarlo.Collision.ScatteringCenterDefinition class
#-----------------------------------------------------------------------------#

# System imports
import numpy
import sys
import unittest
from optparse import *

# Parse the command-line arguments
parser = OptionParser()
parser.add_option("-v", "--verbosity", type="int", dest="verbosity", default=2,
                  help="set the verbosity level [default 2]")

options,args = parser.parse_args()

from testingHelpers import importPyFrensieModuleFromBuildDir
Data = importPyFrensieModuleFromBuildDir('Data')
MonteCarlo = importPyFrensieModuleFromBuildDir('MonteCarlo')
Collision = importPyFrensieModuleFromBuildDir('MonteCarlo.Collision')

#-----------------------------------------------------------------------------#
# Tests.
#-----------------------------------------------------------------------------#
# Test the ScatteringCenterDefinition class
class ScatteringCenterDefinitionTestCase(unittest.TestCase):
    "TestCase class for MonteCarlo.Collision.ScatteringCenterDefinition class"

    def testDefaults(self):
        test = 2
        "*Test MonteCarlo.Collision.ScatteringCenterDefinition defaults"
        zaid = Data.ZAID(1000)
        properties = MonteCarlo.SimulationProperties()
        definition = Collision.ScatteringCenterDefinition( "H-Native", Data.ZAID(1000) )

        # # General properties
        # self.assertEqual( properties.getParticleMode(),
        #                   MonteCarlo.NEUTRON_MODE )
        # self.assertEqual( properties.getNumberOfHistories(), 0 )
        # self.assertEqual( properties.getSurfaceFluxEstimatorAngleCosineCutoff(), 0.001 )
        # self.assertTrue( properties.displayWarnings() )
        # self.assertFalse(properties.isImplicitCaptureModeOn() )

# //---------------------------------------------------------------------------//
# // Tests.
# //---------------------------------------------------------------------------//
# // Check that the name can be returned
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, getName )
# {
#   std::unique_ptr<MonteCarlo::ScatteringCenterDefinition>
#     definition( new MonteCarlo::ScatteringCenterDefinition( "H-Native", 1000 ) );

#   FRENSIE_CHECK_EQUAL( definition->getName(), "H-Native" );

#   definition.reset( new MonteCarlo::ScatteringCenterDefinition( 1000 ) );

#   FRENSIE_CHECK_EQUAL( definition->getName(), "H" );

#   definition.reset( new MonteCarlo::ScatteringCenterDefinition( "He3-Native", 2003 ) );

#   FRENSIE_CHECK_EQUAL( definition->getName(), "He3-Native" );

#   definition.reset( new MonteCarlo::ScatteringCenterDefinition( 2003 ) );

#   FRENSIE_CHECK_EQUAL( definition->getName(), "He3" );

#   FRENSIE_CHECK_THROW( definition.reset( new MonteCarlo::ScatteringCenterDefinition( "", 1000 ) ),
#                        std::runtime_error );
# }

# //---------------------------------------------------------------------------//
# // Check that the zaid can be returned
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, getZAID )
# {
#   std::unique_ptr<MonteCarlo::ScatteringCenterDefinition>
#     definition( new MonteCarlo::ScatteringCenterDefinition( "H-Native", 1000 ) );

#   FRENSIE_CHECK_EQUAL( definition->getZAID(), Data::ZAID(1000) );

#   definition.reset( new MonteCarlo::ScatteringCenterDefinition( 2003 ) );

#   FRENSIE_CHECK_EQUAL( definition->getZAID(), Data::ZAID(2003) );
# }

# //---------------------------------------------------------------------------//
# // Check that the atomic weight can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setAtomicWeight )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1", 1001 );

#   FRENSIE_CHECK( !definition.isAtomicWeightSet() );
#   FRENSIE_CHECK_THROW( definition.getAtomicWeight(), std::runtime_error );
#   FRENSIE_CHECK_THROW( definition.getAtomicWeightRatio(), std::runtime_error );

#   definition.setAtomicWeight( 1.0 );

#   FRENSIE_CHECK( definition.isAtomicWeightSet() );
#   FRENSIE_CHECK_EQUAL( definition.getAtomicWeight(), 1.0 );
#   FRENSIE_CHECK_FLOATING_EQUALITY( definition.getAtomicWeightRatio(),
#                                    9.914095197851978680e-01,
#                                    1e-15 );
# }

# //---------------------------------------------------------------------------//
# // Check that the atomic weight ratio can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefintion, setAtomicWeightRatio )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1", 1001 );

#   FRENSIE_CHECK( !definition.isAtomicWeightSet() );
#   FRENSIE_CHECK_THROW( definition.getAtomicWeightRatio(), std::runtime_error );
#   FRENSIE_CHECK_THROW( definition.getAtomicWeight(), std::runtime_error );

#   definition.setAtomicWeightRatio( 9.914095197851978680e-01 );

#   FRENSIE_CHECK( definition.isAtomicWeightSet() );
#   FRENSIE_CHECK_EQUAL( definition.getAtomicWeightRatio(),
#                        9.914095197851978680e-01 );
#   FRENSIE_CHECK_FLOATING_EQUALITY( definition.getAtomicWeight(), 1.0, 1e-15 );
# }

# //---------------------------------------------------------------------------//
# // Check that photoatomic data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setPhotoatomicDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H-Native", 1000 );

#   FRENSIE_CHECK( !definition.hasPhotoatomicDataProperties() );

#   std::shared_ptr<const Data::PhotoatomicDataProperties> properties(
#                new Data::NativeEPRPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#   definition.setPhotoatomicDataProperties( properties );

#   FRENSIE_CHECK( definition.hasPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotoatomicDataProperties() );

#   double atomic_weight;

#   definition.getPhotoatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.0 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getPhotoatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setPhotoatomicDataProperties( std::shared_ptr<const Data::PhotoatomicDataProperties>() );

#   FRENSIE_CHECK( definition.hasPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotoatomicDataProperties() );

#   // Properties for a different atom will result in a warning
#   properties.reset( new Data::NativeEPRPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::He_ATOM ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotoatomicDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that adjoint photoatomic data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setAdjointPhotoatomicDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H-Native", 1000 );

#   FRENSIE_CHECK( !definition.hasAdjointPhotoatomicDataProperties() );

#   std::shared_ptr<const Data::AdjointPhotoatomicDataProperties> properties(
#                new Data::NativeEPRAdjointPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#   definition.setAdjointPhotoatomicDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotoatomicDataProperties() );

#   double atomic_weight;

#   definition.getAdjointPhotoatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.0 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getAdjointPhotoatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setAdjointPhotoatomicDataProperties( std::shared_ptr<const Data::AdjointPhotoatomicDataProperties>() );

#   FRENSIE_CHECK( definition.hasAdjointPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotoatomicDataProperties() );

#   // Properties for a different atom will result in a warning
#   properties.reset( new Data::NativeEPRAdjointPhotoatomicDataProperties(
#                                              4.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::He_ATOM ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointPhotoatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotoatomicDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that electroatomic data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setElectroatomicDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H-Native", 1000 );

#   FRENSIE_CHECK( !definition.hasElectroatomicDataProperties() );

#   std::shared_ptr<const Data::ElectroatomicDataProperties> properties(
#                new Data::NativeEPRElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#   definition.setElectroatomicDataProperties( properties );

#   FRENSIE_CHECK( definition.hasElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getElectroatomicDataProperties() );

#   double atomic_weight;

#   definition.getElectroatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.0 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getElectroatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setElectroatomicDataProperties( std::shared_ptr<const Data::ElectroatomicDataProperties>() );

#   FRENSIE_CHECK( definition.hasElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getElectroatomicDataProperties() );

#   // Properties for a different atom will result in a warning
#   properties.reset( new Data::NativeEPRElectroatomicDataProperties(
#                                              4.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::He_ATOM ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getElectroatomicDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that adjoint electroatomic data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setAdjointElectroatomicDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H-Native", 1000 );

#   FRENSIE_CHECK( !definition.hasAdjointElectroatomicDataProperties() );

#   std::shared_ptr<const Data::AdjointElectroatomicDataProperties> properties(
#                new Data::NativeEPRAdjointElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#   definition.setAdjointElectroatomicDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointElectroatomicDataProperties() );

#   double atomic_weight;

#   definition.getAdjointElectroatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.0 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getAdjointElectroatomicDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setAdjointElectroatomicDataProperties( std::shared_ptr<const Data::AdjointElectroatomicDataProperties>() );

#   FRENSIE_CHECK( definition.hasAdjointElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointElectroatomicDataProperties() );

#   // Properties for a different atom will result in a warning
#   properties.reset( new Data::NativeEPRAdjointElectroatomicDataProperties(
#                                              4.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::He_ATOM ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointElectroatomicDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointElectroatomicDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that nuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setNuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasNuclearDataProperties() );

#   std::shared_ptr<const Data::NuclearDataProperties> properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#   definition.setNuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getNuclearDataProperties() );

#   double atomic_weight_ratio;

#   definition.getNuclearDataProperties( &atomic_weight_ratio );

#   FRENSIE_CHECK_EQUAL( atomic_weight_ratio, 1.0 );

#   definition.setAtomicWeightRatio( 0.9 );

#   definition.getNuclearDataProperties( &atomic_weight_ratio );

#   FRENSIE_CHECK_EQUAL( atomic_weight_ratio, 0.9 );

#   // A NULL pointer should be ignored
#   definition.setNuclearDataProperties( std::shared_ptr<const Data::NuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getNuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::ACENuclearDataProperties(
#                                              2.0,
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "2003.71c" ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getNuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that adjoint nuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition,
#                    setAdjointNuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasAdjointNuclearDataProperties() );

#   std::shared_ptr<const Data::AdjointNuclearDataProperties> properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-8*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#   definition.setAdjointNuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointNuclearDataProperties() );

#   double atomic_weight_ratio;

#   definition.getAdjointNuclearDataProperties( &atomic_weight_ratio );

#   FRENSIE_CHECK_EQUAL( atomic_weight_ratio, 1.0 );

#   definition.setAtomicWeightRatio( 0.9 );

#   definition.getAdjointNuclearDataProperties( &atomic_weight_ratio );

#   FRENSIE_CHECK_EQUAL( atomic_weight_ratio, 0.9 );

#   // A NULL pointer should be ignored
#   definition.setAdjointNuclearDataProperties( std::shared_ptr<const Data::AdjointNuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasAdjointNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointNuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::TestAdjointNuclearDataProperties(
#                                2003,
#                                1.0,
#                                2.52574e-8*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointNuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that thermal nuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setThermalNuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1 in H2O-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasThermalNuclearDataProperties() );

#   std::shared_ptr<const Data::ThermalNuclearDataProperties> properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.71t" ) );

#   definition.setThermalNuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getThermalNuclearDataProperties() );

#   // A NULL pointer should be ignored
#   definition.setThermalNuclearDataProperties( std::shared_ptr<const Data::ThermalNuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getThermalNuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::ACEThermalNuclearDataProperties(
#                                              {1002, 8016},
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "hvwtr.71t" ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getThermalNuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that adjoint thermal nuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setAdjointThermalNuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1 in H2O-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasAdjointThermalNuclearDataProperties() );

#   std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-8*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#   definition.setAdjointThermalNuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointThermalNuclearDataProperties() );

#   // A NULL pointer should be ignored
#   definition.setAdjointThermalNuclearDataProperties( std::shared_ptr<const Data::AdjointThermalNuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasAdjointThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointThermalNuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::TestAdjointThermalNuclearDataProperties(
#                         "heavy water",
#                         {1002, 8016},
#                         2.52574e-8*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointThermalNuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointThermalNuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that photonuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setPhotonuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasPhotonuclearDataProperties() );

#   std::shared_ptr<const Data::PhotonuclearDataProperties> properties(
#                new Data::ACEPhotonuclearDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.10u" ) );

#   definition.setPhotonuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotonuclearDataProperties() );

#   double atomic_weight;

#   definition.getPhotonuclearDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.0 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getPhotonuclearDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setPhotonuclearDataProperties( std::shared_ptr<const Data::PhotonuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotonuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::ACEPhotonuclearDataProperties(
#                                              2.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "2003.10u" ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getPhotonuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that adjoint aphotonuclear data properties can be set
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, setAdjointPhotonuclearDataProperties )
# {
#   MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#   FRENSIE_CHECK( !definition.hasAdjointPhotonuclearDataProperties() );

#   std::shared_ptr<const Data::AdjointPhotonuclearDataProperties> properties(
#                new Data::TestAdjointPhotonuclearDataProperties(
#                           1001,
#                           1.0,
#                           Data::AdjointPhotonuclearDataProperties::Native_FILE,
#                           0 ) );

#   definition.setAdjointPhotonuclearDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotonuclearDataProperties() );

#   double atomic_weight;

#   definition.getAdjointPhotonuclearDataProperties( &atomic_weight );

#   FRENSIE_CHECK_FLOATING_EQUALITY( atomic_weight,
#                                    1.008664916004299972e+00,
#                                    1e-15 );

#   definition.setAtomicWeight( 1.1 );

#   definition.getAdjointPhotonuclearDataProperties( &atomic_weight );

#   FRENSIE_CHECK_EQUAL( atomic_weight, 1.1 );

#   // A NULL pointer should be ignored
#   definition.setAdjointPhotonuclearDataProperties( std::shared_ptr<const Data::AdjointPhotonuclearDataProperties>() );

#   FRENSIE_CHECK( definition.hasAdjointPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotonuclearDataProperties() );

#   // Properties for a different nuclide will result in a warning
#   properties.reset( new Data::TestAdjointPhotonuclearDataProperties(
#                           2003,
#                           2.0,
#                           Data::AdjointPhotonuclearDataProperties::Native_FILE,
#                           0 ) );

#   definition.setDataProperties( properties );

#   FRENSIE_CHECK( definition.hasAdjointPhotonuclearDataProperties() );
#   FRENSIE_CHECK( properties.get() == &definition.getAdjointPhotonuclearDataProperties() );
# }

# //---------------------------------------------------------------------------//
# // Check that setting nuclear data properties with different temperature
# // evaluations will trigger a warning
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, warn_different_temps )
# {
#   // Set the nuclear data first
#   {
#     MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#     std::shared_ptr<const Data::NuclearDataProperties> nuclear_properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#     definition.setDataProperties( nuclear_properties );

#     std::shared_ptr<const Data::ThermalNuclearDataProperties> thermal_nuclear_properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.81t" ) );

#     definition.setDataProperties( thermal_nuclear_properties );

#     std::shared_ptr<const Data::AdjointNuclearDataProperties> adjoint_nuclear_properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-7*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#     definition.setDataProperties( adjoint_nuclear_properties );

#     std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> adjoint_thermal_nuclear_properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-7*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#     definition.setDataProperties( adjoint_thermal_nuclear_properties );
#   }

#   // Set the thermal nuclear data first
#   {
#     MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#     std::shared_ptr<const Data::ThermalNuclearDataProperties> thermal_nuclear_properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.81t" ) );

#     definition.setDataProperties( thermal_nuclear_properties );

#     std::shared_ptr<const Data::NuclearDataProperties> nuclear_properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#     definition.setDataProperties( nuclear_properties );

#     std::shared_ptr<const Data::AdjointNuclearDataProperties> adjoint_nuclear_properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-7*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#     definition.setDataProperties( adjoint_nuclear_properties );

#     std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> adjoint_thermal_nuclear_properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-7*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#     definition.setDataProperties( adjoint_thermal_nuclear_properties );
#   }

#   // Set the adjoint nuclear data first
#   {
#     MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#     std::shared_ptr<const Data::AdjointNuclearDataProperties> adjoint_nuclear_properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-8*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#     definition.setDataProperties( adjoint_nuclear_properties );

#     std::shared_ptr<const Data::NuclearDataProperties> nuclear_properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#     definition.setDataProperties( nuclear_properties );

#     std::shared_ptr<const Data::ThermalNuclearDataProperties> thermal_nuclear_properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.81t" ) );

#     definition.setDataProperties( thermal_nuclear_properties );

#     std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> adjoint_thermal_nuclear_properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-7*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#     definition.setDataProperties( adjoint_thermal_nuclear_properties );
#   }

#   // Set the adjoint thermal nuclear data first
#   {
#     MonteCarlo::ScatteringCenterDefinition definition( "H1-293.1K", 1001 );

#     std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> adjoint_thermal_nuclear_properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-8*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#     definition.setDataProperties( adjoint_thermal_nuclear_properties );

#     std::shared_ptr<const Data::NuclearDataProperties> nuclear_properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#     definition.setDataProperties( nuclear_properties );

#     std::shared_ptr<const Data::ThermalNuclearDataProperties> thermal_nuclear_properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-7*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.81t" ) );

#     definition.setDataProperties( thermal_nuclear_properties );

#     std::shared_ptr<const Data::AdjointNuclearDataProperties> adjoint_nuclear_properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-7*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#     definition.setDataProperties( adjoint_nuclear_properties );
#   }
# }

# //---------------------------------------------------------------------------//
# // Check that a scattering center definition can be placed in a stream
# FRENSIE_UNIT_TEST( ScatteringCenterDefinition, toStream )
# {
#   MonteCarlo::ScatteringCenterDefinition h_definition( 1000 );

#   MonteCarlo::ScatteringCenterDefinition h1_definition( "H1-293.1K", 1001 );

#   {
#     std::shared_ptr<const Data::PhotoatomicDataProperties> properties(
#                new Data::NativeEPRPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#     h_definition.setDataProperties( properties );
#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::AdjointPhotoatomicDataProperties> properties(
#                new Data::NativeEPRAdjointPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#     h_definition.setDataProperties( properties );
#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::ElectroatomicDataProperties> properties(
#                new Data::NativeEPRElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#     h_definition.setDataProperties( properties );
#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::AdjointElectroatomicDataProperties> properties(
#                new Data::NativeEPRAdjointElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#     h_definition.setDataProperties( properties );
#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::NuclearDataProperties> properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::AdjointNuclearDataProperties> properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-8*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::ThermalNuclearDataProperties> properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.71t" ) );

#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-8*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::PhotonuclearDataProperties> properties(
#                new Data::ACEPhotonuclearDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.10u" ) );

#     h1_definition.setDataProperties( properties );
#   }

#   {
#     std::shared_ptr<const Data::AdjointPhotonuclearDataProperties> properties(
#                new Data::TestAdjointPhotonuclearDataProperties(
#                           1001,
#                           1.0,
#                           Data::AdjointPhotonuclearDataProperties::Native_FILE,
#                           0 ) );

#     h1_definition.setDataProperties( properties );
#   }

#   FRENSIE_CHECK_NO_THROW( std::cout << h_definition << std::endl; );
#   FRENSIE_CHECK_NO_THROW( std::cout << h1_definition << std::endl; );
# }

# //---------------------------------------------------------------------------//
# // Check that a definition can be archived
# FRENSIE_UNIT_TEST_TEMPLATE_EXPAND( ScatteringCenterDefinition,
#                                    archive,
#                                    TestArchives )
# {
#   FETCH_TEMPLATE_PARAM( 0, RawOArchive );
#   FETCH_TEMPLATE_PARAM( 1, RawIArchive );

#   typedef typename std::remove_pointer<RawOArchive>::type OArchive;
#   typedef typename std::remove_pointer<RawIArchive>::type IArchive;

#   std::string archive_base_name( "test_scattering_center_definition" );
#   std::ostringstream archive_ostream;

#   {
#     std::unique_ptr<OArchive> oarchive;

#     createOArchive( archive_base_name, archive_ostream, oarchive );

#     MonteCarlo::ScatteringCenterDefinition h_definition( 1000 );

#     MonteCarlo::ScatteringCenterDefinition h1_definition( "H1-293.1K", 1001 );
#     h1_definition.setAtomicWeight( 1.0 );

#     {
#       std::shared_ptr<const Data::PhotoatomicDataProperties> properties(
#                new Data::NativeEPRPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#       h_definition.setDataProperties( properties );
#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::AdjointPhotoatomicDataProperties> properties(
#                new Data::NativeEPRAdjointPhotoatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#       h_definition.setDataProperties( properties );
#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::ElectroatomicDataProperties> properties(
#                new Data::NativeEPRElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#       h_definition.setDataProperties( properties );
#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::AdjointElectroatomicDataProperties> properties(
#                new Data::NativeEPRAdjointElectroatomicDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              Data::H_ATOM ) );

#       h_definition.setDataProperties( properties );
#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::NuclearDataProperties> properties(
#                new Data::ACENuclearDataProperties(
#                                              1.0,
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.71c" ) );

#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::AdjointNuclearDataProperties> properties(
#                new Data::TestAdjointNuclearDataProperties(
#                                1001,
#                                1.0,
#                                2.52574e-8*MeV,
#                                Data::AdjointNuclearDataProperties::Native_FILE,
#                                0 ) );

#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::ThermalNuclearDataProperties> properties(
#                new Data::ACEThermalNuclearDataProperties(
#                                              {1001, 1002, 8016},
#                                              2.52574e-8*MeV,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "ltwtr.71t" ) );

#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::AdjointThermalNuclearDataProperties> properties(
#                new Data::TestAdjointThermalNuclearDataProperties(
#                         "light water",
#                         {1001, 1002, 8016},
#                         2.52574e-8*MeV,
#                         Data::AdjointThermalNuclearDataProperties::Native_FILE,
#                         0 ) );

#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::PhotonuclearDataProperties> properties(
#                new Data::ACEPhotonuclearDataProperties(
#                                              1.0*amu,
#                                              boost::filesystem::current_path(),
#                                              0,
#                                              "1001.10u" ) );

#       h1_definition.setDataProperties( properties );
#     }

#     {
#       std::shared_ptr<const Data::AdjointPhotonuclearDataProperties> properties(
#                new Data::TestAdjointPhotonuclearDataProperties(
#                           1001,
#                           1.0,
#                           Data::AdjointPhotonuclearDataProperties::Native_FILE,
#                           0 ) );

#       h1_definition.setDataProperties( properties );
#     }

#     FRENSIE_REQUIRE_NO_THROW( (*oarchive) << BOOST_SERIALIZATION_NVP( h_definition ) );
#     FRENSIE_REQUIRE_NO_THROW( (*oarchive) << BOOST_SERIALIZATION_NVP( h1_definition ) );
#   }

#   // Copy the archive ostream to an istream
#   std::istringstream archive_istream( archive_ostream.str() );

#   // Load the archived distributions
#   std::unique_ptr<IArchive> iarchive;

#   createIArchive( archive_istream, iarchive );

#   MonteCarlo::ScatteringCenterDefinition h_definition( "dummy", 10000 );
#   MonteCarlo::ScatteringCenterDefinition h1_definition( "dummy", 8016 );

#   FRENSIE_REQUIRE_NO_THROW( (*iarchive) >> BOOST_SERIALIZATION_NVP( h_definition ) );
#   FRENSIE_REQUIRE_NO_THROW( (*iarchive) >> BOOST_SERIALIZATION_NVP( h1_definition ) );

#   iarchive.reset();

#   FRENSIE_CHECK_EQUAL( h_definition.getName(), "H" );
#   FRENSIE_CHECK_EQUAL( h_definition.getZAID(), Data::ZAID(1000) );
#   FRENSIE_CHECK( !h_definition.isAtomicWeightSet() );
#   FRENSIE_REQUIRE( h_definition.hasPhotoatomicDataProperties() );
#   FRENSIE_REQUIRE( h_definition.hasAdjointPhotoatomicDataProperties() );
#   FRENSIE_REQUIRE( h_definition.hasElectroatomicDataProperties() );
#   FRENSIE_REQUIRE( h_definition.hasAdjointElectroatomicDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasNuclearDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasAdjointNuclearDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasThermalNuclearDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasAdjointThermalNuclearDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasPhotonuclearDataProperties() );
#   FRENSIE_CHECK( !h_definition.hasAdjointPhotonuclearDataProperties() );

#   FRENSIE_CHECK_EQUAL( h1_definition.getName(), "H1-293.1K" );
#   FRENSIE_CHECK_EQUAL( h1_definition.getZAID(), Data::ZAID(1001) );
#   FRENSIE_REQUIRE( h1_definition.isAtomicWeightSet() );
#   FRENSIE_CHECK_EQUAL( h1_definition.getAtomicWeight(), 1.0 );
#   FRENSIE_REQUIRE( h1_definition.hasPhotoatomicDataProperties() );
#   FRENSIE_REQUIRE( h1_definition.hasAdjointPhotoatomicDataProperties() );
#   FRENSIE_REQUIRE( h1_definition.hasElectroatomicDataProperties() );
#   FRENSIE_REQUIRE( h1_definition.hasAdjointElectroatomicDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasNuclearDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasAdjointNuclearDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasThermalNuclearDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasAdjointThermalNuclearDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasPhotonuclearDataProperties() );
#   FRENSIE_CHECK( h1_definition.hasAdjointPhotonuclearDataProperties() );

#   FRENSIE_CHECK( &h_definition.getPhotoatomicDataProperties() ==
#                  &h1_definition.getPhotoatomicDataProperties() );
#   FRENSIE_CHECK( &h_definition.getAdjointPhotoatomicDataProperties() ==
#                  &h1_definition.getAdjointPhotoatomicDataProperties() );
#   FRENSIE_CHECK( &h_definition.getElectroatomicDataProperties() ==
#                  &h1_definition.getElectroatomicDataProperties() );
#   FRENSIE_CHECK( &h_definition.getAdjointElectroatomicDataProperties() ==
#                  &h1_definition.getAdjointElectroatomicDataProperties() );
# }

#-----------------------------------------------------------------------------#
# Custom main
#-----------------------------------------------------------------------------#
if __name__ == "__main__":

    # Create the testSuite object
    suite = unittest.TestSuite()

    # Add the test cases to the testSuite
    suite.addTest(unittest.makeSuite(ScatteringCenterDefinitionTestCase))

    print >>sys.stderr, \
        "\n**************************************\n" + \
        "Testing MonteCarlo.Model \n" + \
        "**************************************\n"
    result = unittest.TextTestRunner(verbosity=options.verbosity).run(suite)

    errs_plus_fails = len(result.errors) + len(result.failures)

    if errs_plus_fails == 0:
        print "End Result: TEST PASSED"

    # Delete the suite
    del suite

    # Exit
    sys.exit(errs_plus_fails)

#-----------------------------------------------------------------------------#
# end tstMonteCarlo.Collision.ScatteringCenterDefinition.py
#-----------------------------------------------------------------------------#
